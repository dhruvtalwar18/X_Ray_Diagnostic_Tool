#keep this file in a folder name X also create folder name "images": to add image, "final": empty folder for output import numpy as npimport cv2import matplotlib.pyplot as pltimport globimport jsonx=5refPt = []stats = []def click_and_crop(event, x, y, flags, param):    global refPt    if event == cv2.EVENT_LBUTTONDOWN:        cv2.circle(dotted,(x, y), 3, (255,255,255), -1)        refPt.append((x, y))        def chest_area(event, x, y, flags, param):        global refPt        if event == cv2.EVENT_LBUTTONDOWN:                refPt = [(x, y)]        elif event == cv2.EVENT_LBUTTONUP:                refPt.append((x, y))                cv2.rectangle(dotted, refPt[0], refPt[1], (255, 255, 255), 2)                cv2.imshow("chest", dotted)def cropped(im):    global refPt    pts = np.array([[x[0],x[1]] for x in refPt])    rect = cv2.boundingRect(pts)    x,y,w,h = rect    croped = im[y:y+h, x:x+w].copy()    pts = pts - pts.min(axis=0)    mask = np.zeros(croped.shape[:2], np.uint8)    cv2.drawContours(mask, [pts], -1, (255, 255, 255), -1, cv2.LINE_AA)    im[y:y+h, x:x+w] = mask[:,:]def improve_accuracy(otsu_thresh, alpha=0.75, limit=100):    u, ml_c = np.unique(mask_left,return_counts=True)    u, mr_c = np.unique(mask_right,return_counts=True)        ml = np.zeros(image.shape,np.uint8)    mr = np.zeros(image.shape,np.uint8)    # kk=0    for kk in range(limit):    # while True:        x=[0,0]        u, cnt_l = np.unique(ml,return_counts=True)        u, cnt_r = np.unique(mr,return_counts=True)        ret,im = cv2.threshold(image,otsu_thresh+(kk*5),255,cv2.THRESH_BINARY)        # print(cnt_l,cnt_r)        if  kk !=0 and  cnt_l[1]/ml_c[1] > alpha:            x[0]=1        else:            ml = np.zeros(image.shape,np.uint8)            for i in range(im.shape[0]):                for j in range(im.shape[1]):                    if im[i][j]==0 and mask_left[i][j]==255:                        ml[i][j]=255        if kk != 0 and cnt_r[1]/mr_c[1] > alpha:            x[1]=1        else:            mr = np.zeros(image.shape,np.uint8)            for i in range(im.shape[0]):                for j in range(im.shape[1]):                    if im[i][j]==0 and mask_right[i][j]==255:                        mr[i][j]=255        if x[0]==1 and x[1]==1:            break        kk+=1        for i in range(ml.shape[0]):        for j in range(ml.shape[1]):            if ml[i][j]==255:                otsu_mask_left[i][j]=255                otsu_mask[i][j]=255                orig[i][j]=clone[i][j]                                    orig_left[i][j]=clone[i][j]            if mr[i][j]==255:                otsu_mask_right[i][j]=255                otsu_mask[i][j]=255                orig_right[i][j]=clone[i][j]                orig[i][j]=clone[i][j]for file in glob.glob('./images/*.jpeg'):    refPt = []    x+=1    # file='./post/2p.jpg'    image = cv2.imread(file, 0)    image = cv2.resize(image, (312, 416))    #print(np.unique(image,return_counts=True))    dotted = image.copy()    clone = image.copy()    mask_left = np.zeros(image.shape,np.uint8)    mask_right = np.zeros(image.shape,np.uint8)    '''To record points'''    cv2.namedWindow("image")    cv2.imshow("image", dotted)    cv2.setMouseCallback("image", click_and_crop)    while True:        cv2.imshow("image", dotted)        key = cv2.waitKey(1) & 0xFF        if key == ord("q"):            dotted=clone.copy()            refPt = []        elif key == ord("l"):            cropped(mask_left)            left = image[refPt[0][1]:refPt[1][1],refPt[0][0]:refPt[1][0]]            refPt = []        elif key == ord("r"):            right = image[refPt[0][1]:refPt[1][1],refPt[0][0]:refPt[1][0]]            cropped(mask_right)            refPt = []        elif key == ord("c"):            break    cv2.imwrite("./test/"+str(x)+"_left_boundry.jpg",left)    cv2.imwrite("./test/"+str(x)+"_right_boundry.jpg",right)             otsu_mask_left = np.zeros(image.shape,np.uint8)    otsu_mask_right = np.zeros(image.shape,np.uint8)    otsu_mask = np.zeros(image.shape,np.uint8)    orig_left = np.zeros(image.shape,np.uint8)    orig_right = np.zeros(image.shape,np.uint8)    orig = np.zeros(image.shape,np.uint8)    ret, oo = cv2.threshold(image, 0, 255, cv2.THRESH_OTSU)        ret,mask_left = cv2.threshold(mask_left,127,255,cv2.THRESH_BINARY)    ret,mask_right = cv2.threshold(mask_right,127,255,cv2.THRESH_BINARY)    # print(np.unique(oo),np.unique(mask_right),np.unique(mask_left,return_counts=True))    improve_accuracy(ret)    cv2.destroyAllWindows()    dotted_clone = dotted.copy()    cv2.namedWindow("chest")    cv2.setMouseCallback("chest", chest_area)    while True:        cv2.imshow("chest", dotted)        key = cv2.waitKey(1) & 0xFF        if key == ord("q"):            dotted = dotted_clone            refPt = []        elif key == ord("c"):            break    vol = (refPt[1][0]-refPt[0][0]) * (refPt[1][1]- refPt[0][1])     uni, cnt_l = np.unique(otsu_mask_left, return_counts=True)    uni, cnt_r = np.unique(otsu_mask_right, return_counts=True)        cv2.imwrite("./final/"+str(x)+".jpg",clone)    cv2.imwrite("./final/"+str(x)+"_Points.jpg",dotted)    cv2.imwrite("./final/"+str(x)+"_mask.jpg",otsu_mask)    cv2.imwrite("./final/"+str(x)+"_applied_mask.jpg",orig)    cv2.imwrite("./final/"+str(x)+"_mask_left.jpg",otsu_mask_left)    cv2.imwrite("./final/"+str(x)+"_mask_right.jpg",otsu_mask_right)    cv2.destroyAllWindows()